/**
 * Rules
 * The filter works as a series of rules so that each word can be mapped to a rule.  So \"Happy\" can become \"happy\" and \"b4d\" and become \"bad\".    With this API you can manage your rules. 
 *
 * OpenAPI spec version: 2.0.3
 * Contact: support@twohat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs';

import { Ai } from '../model/ai';
import { Body } from '../model/body';
import { ChangeLog } from '../model/changeLog';
import { ClientId } from '../model/clientId';
import { Comment } from '../model/comment';
import { CommentInput } from '../model/commentInput';
import { ExampleDiff } from '../model/exampleDiff';
import { Flag } from '../model/flag';
import { InlineResponse200 } from '../model/inlineResponse200';
import { ModeratorId } from '../model/moderatorId';
import { Rule } from '../model/rule';
import { RuleText } from '../model/ruleText';
import { Timestamp } from '../model/timestamp';
import { Topics } from '../model/topics';
import { UpdateTopic } from '../model/updateTopic';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://virtserver.swaggerhub.com/twohat/rules/2.0.3';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add a comment to this rule
     * Comments are ways to leave a note to say why a person made the decision they did.  Or it could be a question or answer trying to get help on an item. 
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param text The text of the rule you want to work on
     * @param body 
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling addComment.');
        }

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling addComment.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Comment>('post', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an alternate sense for a rule
     * This will delete an alternate sense for rule and log the change
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param dependency This is the related text you want to work on.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteAlternateSense.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteAlternateSense.');
        }

        if (dependency === null || dependency === undefined) {
            throw new Error('Required parameter dependency was null or undefined when calling deleteAlternateSense.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_senses/${encodeURIComponent(String(dependency))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an alternate spelling for a rule
     * This will delete an alternate spelling for rule and log the change
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param dependency This is the related text you want to work on.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteAlternateSpelling.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteAlternateSpelling.');
        }

        if (dependency === null || dependency === undefined) {
            throw new Error('Required parameter dependency was null or undefined when calling deleteAlternateSpelling.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_spellings/${encodeURIComponent(String(dependency))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a comment
     * Remove a comment
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param commentId The unique identifier for the comment
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteComment.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling deleteComment.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse200>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an flag for a rule
     * This will delete a flag for rule and log the change
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param flag The name of the flag to change
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteFlag.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteFlag.');
        }

        if (flag === null || flag === undefined) {
            throw new Error('Required parameter flag was null or undefined when calling deleteFlag.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/flags/${encodeURIComponent(String(flag))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a leet mapping for a rule
     * This will delete a leet mapping for rule and log the change
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param dependency This is the related text you want to work on.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteLeetMapping.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteLeetMapping.');
        }

        if (dependency === null || dependency === undefined) {
            throw new Error('Required parameter dependency was null or undefined when calling deleteLeetMapping.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/leet_mappings/${encodeURIComponent(String(dependency))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a rule
     * This will delete a rule and log the change
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteRule.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteRule.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a topic for a rule
     * This will delete a topic for rule and log the change
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param topicId The topic is the id for topic.  See documentation on Topic for what the ids are
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling deleteTopic.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling deleteTopic.');
        }

        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling deleteTopic.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/topic/${encodeURIComponent(String(topicId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get rules that match this prefix
     * Used for autocomplete so you can add alternate senses and fill out the rule 
     * @param prefix The term you want to search for
     * @param clientIds Show results for a several given clients.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param limit Limit the number of results
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RuleText>>;
    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RuleText>>>;
    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RuleText>>>;
    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (prefix === null || prefix === undefined) {
            throw new Error('Required parameter prefix was null or undefined when calling getAutocomplete.');
        }




        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (clientIds) {
            clientIds.forEach((element) => {
                queryParameters = queryParameters.append('clientIds', <any>element);
            })
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<RuleText>>('get', `${this.basePath}/rules/autocomplete/${encodeURIComponent(String(prefix))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a comment
     * Get a comment by Id for this item
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param commentId The unique identifier for the comment
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public getComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public getComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public getComment(text: string, language: string, commentId: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling getComment.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling getComment.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Comment>('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lookup a specific rule
     * This will get the specific rule in JSON format
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRule(text: string, language: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public getRule(text: string, language: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public getRule(text: string, language: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public getRule(text: string, language: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling getRule.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getRule.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of all changes on this rule
     * This will get the full changelog of all changes made to a rule for all clients and languages you are authorized to view. 
     * @param text The text of the rule you want to work on
     * @param languages Which languages does this apply to
     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param refresh Should the database be refreshed to make sure all the rows are updated before calling.    Don&#x27;t do this in production as you will get latency spike and it may not even be turned on for production Used primarily for integration tests. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ChangeLog>>;
    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChangeLog>>>;
    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChangeLog>>>;
    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling getRuleHistory.');
        }






        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }
        if (clientIds) {
            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (refresh !== undefined && refresh !== null) {
            queryParameters = queryParameters.set('refresh', <any>refresh);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ChangeLog>>('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/changelog`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for rules
     * Will get all the rules you have created in the system. For Enterprise Plus clients with a specific confidentiality agreement you may also have the option to review the Sift rules as well. 
     * @param ai Show items the AI predicts as useful because moderators in the past have taken an action on this items.  Passing an array of objects as params can be tricky at first so here is an example &amp;ai[0][minPrediction]&#x3D;0.50&amp;ai[0][modelName]&#x3D;topic_vulgar&amp;ai[0][maxPrediction]&#x3D;0.95&amp;ai[1][minPrediction]&#x3D;0.10&amp;ai[1][modelName]&#x3D;topic_fraud&amp;ai[1][maxPrediction]&#x3D;0.80  In urlencoded form that would be &amp;ai%5B0%5D%5BminPrediction%5D&#x3D;0.50&amp;ai%5B0%5D%5BmodelName%5D&#x3D;topic_vulgar&amp;ai%5B0%5D%5BmaxPrediction%5D&#x3D;0.95&amp;ai%5B1%5D%5BminPrediction%5D&#x3D;0.10&amp;ai%5B1%5D%5BmodelName%5D&#x3D;topic_fraud&amp;ai%5B1%5D%5BmaxPrediction%5D&#x3D;0.80 
     * @param doneByModeratorId Only show work done by this moderatorId
     * @param clientIds Show results for a several given clients.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)
     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)
     * @param lastChangedStartDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)
     * @param lastChangedEndDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)
     * @param deleted Show deleted items
     * @param publishedStartDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)
     * @param publishedEndDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)
     * @param languages Which languages does this apply to
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param altSense Has this word as an alternate sense
     * @param altSpelling Has this word as an alternate spelling
     * @param leetMapping Has this word as a leet mapping
     * @param taskId Is associated with a taskId for doing work
     * @param tags Only find items matching a certain tag
     * @param text Text search.  This uses fuzzy matching.
     * @param topics Only show items for these topics (topicId) between risk level minRisk and maxRisk
     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Rule>>;
    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Rule>>>;
    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Rule>>>;
    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {






















        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (ai) {
            ai.forEach((element) => {
                queryParameters = queryParameters.append('ai', <any>element);
            })
        }
        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);
        }
        if (clientIds) {
            clientIds.forEach((element) => {
                queryParameters = queryParameters.append('clientIds', <any>element);
            })
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (lastChangedStartDate !== undefined && lastChangedStartDate !== null) {
            queryParameters = queryParameters.set('lastChangedStartDate', <any>lastChangedStartDate);
        }
        if (lastChangedEndDate !== undefined && lastChangedEndDate !== null) {
            queryParameters = queryParameters.set('lastChangedEndDate', <any>lastChangedEndDate);
        }
        if (deleted !== undefined && deleted !== null) {
            queryParameters = queryParameters.set('deleted', <any>deleted);
        }
        if (publishedStartDate !== undefined && publishedStartDate !== null) {
            queryParameters = queryParameters.set('publishedStartDate', <any>publishedStartDate);
        }
        if (publishedEndDate !== undefined && publishedEndDate !== null) {
            queryParameters = queryParameters.set('publishedEndDate', <any>publishedEndDate);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (altSense !== undefined && altSense !== null) {
            queryParameters = queryParameters.set('altSense', <any>altSense);
        }
        if (altSpelling !== undefined && altSpelling !== null) {
            queryParameters = queryParameters.set('altSpelling', <any>altSpelling);
        }
        if (leetMapping !== undefined && leetMapping !== null) {
            queryParameters = queryParameters.set('leetMapping', <any>leetMapping);
        }
        if (taskId !== undefined && taskId !== null) {
            queryParameters = queryParameters.set('taskId', <any>taskId);
        }
        if (tags) {
            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (topics) {
            topics.forEach((element) => {
                queryParameters = queryParameters.append('topics', <any>element);
            })
        }
        if (unresolvedComments !== undefined && unresolvedComments !== null) {
            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Rule>>('get', `${this.basePath}/rules`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List comments on this content item
     * 
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listComments(text: string, language: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Comment>>;
    public listComments(text: string, language: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Comment>>>;
    public listComments(text: string, language: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Comment>>>;
    public listComments(text: string, language: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling listComments.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling listComments.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Comment>>('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Mark a comment as resolved (or reopen)
     * Comments can be marked as needing to be answered. 
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param text The text of the rule you want to work on
     * @param commentId The unique identifier for the comment
     * @param body 
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling resolveComment.');
        }

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling resolveComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling resolveComment.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Comment>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}/resolved`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test the impact if you where to upload a rule
     * This will add the rules temporarily in a sandbox environment look for examples of text that might be impacted and send it to the classifier. If the rules contains {{smart_rules}} then it will find all the words in those smart_rules and pull examples with them It will compare the old answer and the new answer and output a list of phrases that are different.  The clientIds param lets you choose which clients to get examples from.  
     * @param body 
     * @param examplesPerRule how many examples should we get per rule or smart_rule part
     * @param clientIds Show results for a several given clients.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe?: 'body', reportProgress?: boolean): Observable<Array<ExampleDiff>>;
    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ExampleDiff>>>;
    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ExampleDiff>>>;
    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {




        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (examplesPerRule !== undefined && examplesPerRule !== null) {
            queryParameters = queryParameters.set('examplesPerRule', <any>examplesPerRule);
        }
        if (clientIds) {
            clientIds.forEach((element) => {
                queryParameters = queryParameters.append('clientIds', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<ExampleDiff>>('put', `${this.basePath}/rules/test`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the current alternate sense (or add if does not exist) with this value.
     * This will update an alternate spelling for a rule and log the change  Alternate senses will replace this word with another word SOMETIMES.  You can have more than one alt sense and it will choose the best one based on context or the higher risk one if they are tied. Typically alternate senses are tied to smart rules like {{first_name}} 
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param dependency This is the related text you want to work on.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateAlternateSense.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateAlternateSense.');
        }

        if (dependency === null || dependency === undefined) {
            throw new Error('Required parameter dependency was null or undefined when calling updateAlternateSense.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_senses/${encodeURIComponent(String(dependency))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the current alternate spelling (or add if does not exist) with this value.
     * This will update an alternate spelling for a rule and log the change  Alternate spellings will replace this word with another word EVERY TIME.  You can have more than one alt spelling and it will choose the best one based on context or the higher risk one if they are tied. 
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param dependency This is the related text you want to work on.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateAlternateSpelling.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateAlternateSpelling.');
        }

        if (dependency === null || dependency === undefined) {
            throw new Error('Required parameter dependency was null or undefined when calling updateAlternateSpelling.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_spellings/${encodeURIComponent(String(dependency))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a comment
     * Comments are ways to leave a note to say why a person made the decision they did.  Or it could be a question or answer trying to get help on an item. 
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param text The text of the rule you want to work on
     * @param commentId The unique identifier for the comment
     * @param body 
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateComment.');
        }

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling updateComment.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Comment>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the a flag associated (or add if does not exist) with this value.
     * This will update a flag with this rule  These are a series of special attributes you can add to an item. For instance if you add FIRST_NAME flag it will automatically add an alt_sense of {{first_name}} and add other logic interally to treat it as potential PII 
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param flag The name of the flag to change
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateFlag.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateFlag.');
        }

        if (flag === null || flag === undefined) {
            throw new Error('Required parameter flag was null or undefined when calling updateFlag.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/flags/${encodeURIComponent(String(flag))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the current leet mapping associated (or add if does not exist) with this value.
     * This will update a leet mapping with this rule  In many cases letters like  or  could be used instead of u  You can map those other letters to u and the system will see if it results in a known word when doing so. 
     * @param text The text of the rule you want to work on
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param dependency This is the related text you want to work on.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateLeetMapping.');
        }

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateLeetMapping.');
        }

        if (dependency === null || dependency === undefined) {
            throw new Error('Required parameter dependency was null or undefined when calling updateLeetMapping.');
        }



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Rule>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/leet_mappings/${encodeURIComponent(String(dependency))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the current rule
     * This will update the current rule to the following
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param text The text of the rule you want to work on
     * @param body 
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateRule.');
        }

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateRule.');
        }




        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Rule>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Insert/Update rules in the system
     * This will update a rule and log the change
     * @param body 
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateRules(body?: Array<Rule>, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public updateRules(body?: Array<Rule>, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public updateRules(body?: Array<Rule>, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public updateRules(body?: Array<Rule>, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {



        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse200>('put', `${this.basePath}/rules`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the current topic (or add if does not exist) with this value.
     * This will update a topic for a rule and log the change
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param text The text of the rule you want to work on
     * @param topicId The topic is the id for topic.  See documentation on Topic for what the ids are
     * @param body 
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param publish This will also make the rule live
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;
    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;
    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;
    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling updateTopic.');
        }

        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling updateTopic.');
        }

        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling updateTopic.');
        }




        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (publish !== undefined && publish !== null) {
            queryParameters = queryParameters.set('publish', <any>publish);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Rule>('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/topic/${encodeURIComponent(String(topicId))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

import {
  InjectionToken,
  ɵɵinject,
  ɵɵdefineInjectable,
  ɵsetClassMetadata,
  Injectable,
  Optional,
  Inject,
  ɵɵdefineNgModule,
  ɵɵdefineInjector,
  NgModule,
  SkipSelf
} from '@angular/core';
import {
  HttpUrlEncodingCodec,
  HttpHeaders,
  HttpParams,
  HttpClient
} from '@angular/common/http';

/**
 * CustomHttpUrlEncodingCodec
 * Fix plus sign (+) not encoding, so sent as blank space
 * See: https://github.com/angular/angular/issues/11058#issuecomment-247367318
 */
class CustomHttpUrlEncodingCodec extends HttpUrlEncodingCodec {
  encodeKey(k) {
    k = super.encodeKey(k);
    return k.replace(/\+/gi, '%2B');
  }
  encodeValue(v) {
    v = super.encodeValue(v);
    return v.replace(/\+/gi, '%2B');
  }
}

const BASE_PATH = new InjectionToken('basePath');
const COLLECTION_FORMATS = {
  'csv': ',',
  'tsv': '   ',
  'ssv': ' ',
  'pipes': '|'
};

class Configuration {
  constructor(configurationParameters = {}) {
    this.apiKeys = configurationParameters.apiKeys;
    this.username = configurationParameters.username;
    this.password = configurationParameters.password;
    this.accessToken = configurationParameters.accessToken;
    this.basePath = configurationParameters.basePath;
    this.withCredentials = configurationParameters.withCredentials;
  }
  /**
   * Select the correct content-type to use for a request.
   * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
   * If no content type is found return the first found type if the contentTypes is not empty
   * @param contentTypes - the array of content types that are available for selection
   * @returns the selected content-type or <code>undefined</code> if no selection could be made.
   */
  selectHeaderContentType(contentTypes) {
    if (contentTypes.length == 0) {
      return undefined;
    }
    let type = contentTypes.find(x => this.isJsonMime(x));
    if (type === undefined) {
      return contentTypes[0];
    }
    return type;
  }
  /**
   * Select the correct accept content-type to use for a request.
   * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
   * If no content type is found return the first found type if the contentTypes is not empty
   * @param accepts - the array of content types that are available for selection.
   * @returns the selected content-type or <code>undefined</code> if no selection could be made.
   */
  selectHeaderAccept(accepts) {
    if (accepts.length == 0) {
      return undefined;
    }
    let type = accepts.find(x => this.isJsonMime(x));
    if (type === undefined) {
      return accepts[0];
    }
    return type;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
    return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
  }
}

/**
 * Rules
 * The filter works as a series of rules so that each word can be mapped to a rule.  So \"Happy\" can become \"happy\" and \"b4d\" and become \"bad\".    With this API you can manage your rules.
 *
 * OpenAPI spec version: 2.0.3
 * Contact: support@twohat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */
class DefaultService {
  constructor(httpClient, basePath, configuration) {
    this.httpClient = httpClient;
    this.basePath = 'https://virtserver.swaggerhub.com/twohat/rules/2.0.3';
    this.defaultHeaders = new HttpHeaders();
    this.configuration = new Configuration();
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }
  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  canConsumeForm(consumes) {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }
  addComment(language, text, body, clientId, observe = 'body', reportProgress = false) {
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling addComment.');
    }
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling addComment.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('post', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteAlternateSense(text, language, dependency, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteAlternateSense.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteAlternateSense.');
    }
    if (dependency === null || dependency === undefined) {
      throw new Error('Required parameter dependency was null or undefined when calling deleteAlternateSense.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_senses/${encodeURIComponent(String(dependency))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteAlternateSpelling(text, language, dependency, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteAlternateSpelling.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteAlternateSpelling.');
    }
    if (dependency === null || dependency === undefined) {
      throw new Error('Required parameter dependency was null or undefined when calling deleteAlternateSpelling.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_spellings/${encodeURIComponent(String(dependency))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteComment(text, language, commentId, clientId, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteComment.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteComment.');
    }
    if (commentId === null || commentId === undefined) {
      throw new Error('Required parameter commentId was null or undefined when calling deleteComment.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteFlag(text, language, flag, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteFlag.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteFlag.');
    }
    if (flag === null || flag === undefined) {
      throw new Error('Required parameter flag was null or undefined when calling deleteFlag.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/flags/${encodeURIComponent(String(flag))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteLeetMapping(text, language, dependency, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteLeetMapping.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteLeetMapping.');
    }
    if (dependency === null || dependency === undefined) {
      throw new Error('Required parameter dependency was null or undefined when calling deleteLeetMapping.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/leet_mappings/${encodeURIComponent(String(dependency))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteRule(text, language, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteRule.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteRule.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  deleteTopic(text, language, topicId, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteTopic.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling deleteTopic.');
    }
    if (topicId === null || topicId === undefined) {
      throw new Error('Required parameter topicId was null or undefined when calling deleteTopic.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/topic/${encodeURIComponent(String(topicId))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  getAutocomplete(prefix, clientIds, languages, limit, observe = 'body', reportProgress = false) {
    if (prefix === null || prefix === undefined) {
      throw new Error('Required parameter prefix was null or undefined when calling getAutocomplete.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (clientIds) {
      clientIds.forEach((element) => {
        queryParameters = queryParameters.append('clientIds', element);
      });
    }
    if (languages) {
      languages.forEach((element) => {
        queryParameters = queryParameters.append('languages', element);
      });
    }
    if (limit !== undefined && limit !== null) {
      queryParameters = queryParameters.set('limit', limit);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules/autocomplete/${encodeURIComponent(String(prefix))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  getComment(text, language, commentId, clientId, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling getComment.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling getComment.');
    }
    if (commentId === null || commentId === undefined) {
      throw new Error('Required parameter commentId was null or undefined when calling getComment.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  getRule(text, language, clientId, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling getRule.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling getRule.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  getRuleHistory(text, languages, clientIds, limit, offset, refresh, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling getRuleHistory.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (languages) {
      languages.forEach((element) => {
        queryParameters = queryParameters.append('languages', element);
      });
    }
    if (clientIds) {
      queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
    }
    if (limit !== undefined && limit !== null) {
      queryParameters = queryParameters.set('limit', limit);
    }
    if (offset !== undefined && offset !== null) {
      queryParameters = queryParameters.set('offset', offset);
    }
    if (refresh !== undefined && refresh !== null) {
      queryParameters = queryParameters.set('refresh', refresh);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/changelog`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  getRules(ai, doneByModeratorId, clientIds, endDate, startDate, lastChangedStartDate, lastChangedEndDate, deleted, publishedStartDate, publishedEndDate, languages, limit, offset, altSense, altSpelling, leetMapping, taskId, tags, text, topics, unresolvedComments, observe = 'body', reportProgress = false) {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (ai) {
      ai.forEach((element) => {
        queryParameters = queryParameters.append('ai', element);
      });
    }
    if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
      queryParameters = queryParameters.set('doneByModeratorId', doneByModeratorId);
    }
    if (clientIds) {
      clientIds.forEach((element) => {
        queryParameters = queryParameters.append('clientIds', element);
      });
    }
    if (endDate !== undefined && endDate !== null) {
      queryParameters = queryParameters.set('endDate', endDate);
    }
    if (startDate !== undefined && startDate !== null) {
      queryParameters = queryParameters.set('startDate', startDate);
    }
    if (lastChangedStartDate !== undefined && lastChangedStartDate !== null) {
      queryParameters = queryParameters.set('lastChangedStartDate', lastChangedStartDate);
    }
    if (lastChangedEndDate !== undefined && lastChangedEndDate !== null) {
      queryParameters = queryParameters.set('lastChangedEndDate', lastChangedEndDate);
    }
    if (deleted !== undefined && deleted !== null) {
      queryParameters = queryParameters.set('deleted', deleted);
    }
    if (publishedStartDate !== undefined && publishedStartDate !== null) {
      queryParameters = queryParameters.set('publishedStartDate', publishedStartDate);
    }
    if (publishedEndDate !== undefined && publishedEndDate !== null) {
      queryParameters = queryParameters.set('publishedEndDate', publishedEndDate);
    }
    if (languages) {
      languages.forEach((element) => {
        queryParameters = queryParameters.append('languages', element);
      });
    }
    if (limit !== undefined && limit !== null) {
      queryParameters = queryParameters.set('limit', limit);
    }
    if (offset !== undefined && offset !== null) {
      queryParameters = queryParameters.set('offset', offset);
    }
    if (altSense !== undefined && altSense !== null) {
      queryParameters = queryParameters.set('altSense', altSense);
    }
    if (altSpelling !== undefined && altSpelling !== null) {
      queryParameters = queryParameters.set('altSpelling', altSpelling);
    }
    if (leetMapping !== undefined && leetMapping !== null) {
      queryParameters = queryParameters.set('leetMapping', leetMapping);
    }
    if (taskId !== undefined && taskId !== null) {
      queryParameters = queryParameters.set('taskId', taskId);
    }
    if (tags) {
      queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
    }
    if (text !== undefined && text !== null) {
      queryParameters = queryParameters.set('text', text);
    }
    if (topics) {
      topics.forEach((element) => {
        queryParameters = queryParameters.append('topics', element);
      });
    }
    if (unresolvedComments !== undefined && unresolvedComments !== null) {
      queryParameters = queryParameters.set('unresolvedComments', unresolvedComments);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  listComments(text, language, clientId, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling listComments.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling listComments.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  resolveComment(language, text, commentId, body, clientId, observe = 'body', reportProgress = false) {
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling resolveComment.');
    }
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling resolveComment.');
    }
    if (commentId === null || commentId === undefined) {
      throw new Error('Required parameter commentId was null or undefined when calling resolveComment.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}/resolved`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  testRules(body, examplesPerRule, clientIds, observe = 'body', reportProgress = false) {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (examplesPerRule !== undefined && examplesPerRule !== null) {
      queryParameters = queryParameters.set('examplesPerRule', examplesPerRule);
    }
    if (clientIds) {
      clientIds.forEach((element) => {
        queryParameters = queryParameters.append('clientIds', element);
      });
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('put', `${this.basePath}/rules/test`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateAlternateSense(text, language, dependency, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateAlternateSense.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateAlternateSense.');
    }
    if (dependency === null || dependency === undefined) {
      throw new Error('Required parameter dependency was null or undefined when calling updateAlternateSense.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_senses/${encodeURIComponent(String(dependency))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateAlternateSpelling(text, language, dependency, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateAlternateSpelling.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateAlternateSpelling.');
    }
    if (dependency === null || dependency === undefined) {
      throw new Error('Required parameter dependency was null or undefined when calling updateAlternateSpelling.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_spellings/${encodeURIComponent(String(dependency))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateComment(language, text, commentId, body, clientId, observe = 'body', reportProgress = false) {
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateComment.');
    }
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateComment.');
    }
    if (commentId === null || commentId === undefined) {
      throw new Error('Required parameter commentId was null or undefined when calling updateComment.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateFlag(text, language, flag, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateFlag.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateFlag.');
    }
    if (flag === null || flag === undefined) {
      throw new Error('Required parameter flag was null or undefined when calling updateFlag.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/flags/${encodeURIComponent(String(flag))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateLeetMapping(text, language, dependency, clientId, publish, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateLeetMapping.');
    }
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateLeetMapping.');
    }
    if (dependency === null || dependency === undefined) {
      throw new Error('Required parameter dependency was null or undefined when calling updateLeetMapping.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/leet_mappings/${encodeURIComponent(String(dependency))}`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateRule(language, text, body, clientId, publish, observe = 'body', reportProgress = false) {
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateRule.');
    }
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateRule.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateRules(body, publish, observe = 'body', reportProgress = false) {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('put', `${this.basePath}/rules`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  updateTopic(language, text, topicId, body, clientId, publish, observe = 'body', reportProgress = false) {
    if (language === null || language === undefined) {
      throw new Error('Required parameter language was null or undefined when calling updateTopic.');
    }
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling updateTopic.');
    }
    if (topicId === null || topicId === undefined) {
      throw new Error('Required parameter topicId was null or undefined when calling updateTopic.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (language !== undefined && language !== null) {
      queryParameters = queryParameters.set('language', language);
    }
    if (clientId !== undefined && clientId !== null) {
      queryParameters = queryParameters.set('clientId', clientId);
    }
    if (publish !== undefined && publish !== null) {
      queryParameters = queryParameters.set('publish', publish);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [
      'application/json'
    ];
    const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }
    return this.httpClient.request('put', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/topic/${encodeURIComponent(String(topicId))}`, {
      body: body,
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
}
DefaultService.ɵfac = function DefaultService_Factory(t) {
  return new(t || DefaultService)(ɵɵinject(HttpClient), ɵɵinject(BASE_PATH, 8), ɵɵinject(Configuration, 8));
};
DefaultService.ɵprov = ɵɵdefineInjectable({
  token: DefaultService,
  factory: DefaultService.ɵfac
});
/*@__PURE__*/
(function () {
  ɵsetClassMetadata(DefaultService, [{
    type: Injectable
  }], function () {
    return [{
      type: HttpClient
    }, {
      type: undefined,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [BASE_PATH]
      }]
    }, {
      type: Configuration,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();

/**
 * Rules
 * The filter works as a series of rules so that each word can be mapped to a rule.  So \"Happy\" can become \"happy\" and \"b4d\" and become \"bad\".    With this API you can manage your rules.
 *
 * OpenAPI spec version: 2.0.3
 * Contact: support@twohat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */
class SIFTADMINService {
  constructor(httpClient, basePath, configuration) {
    this.httpClient = httpClient;
    this.basePath = 'https://virtserver.swaggerhub.com/twohat/rules/2.0.3';
    this.defaultHeaders = new HttpHeaders();
    this.configuration = new Configuration();
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }
  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  canConsumeForm(consumes) {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }
  deleteRuleHistory(text, languages, clientIds, observe = 'body', reportProgress = false) {
    if (text === null || text === undefined) {
      throw new Error('Required parameter text was null or undefined when calling deleteRuleHistory.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (languages) {
      languages.forEach((element) => {
        queryParameters = queryParameters.append('languages', element);
      });
    }
    if (clientIds) {
      queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('delete', `${this.basePath}/rules/text/${encodeURIComponent(String(text))}/changelog`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
  syncRules(since, observe = 'body', reportProgress = false) {
    if (since === null || since === undefined) {
      throw new Error('Required parameter since was null or undefined when calling syncRules.');
    }
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (since !== undefined && since !== null) {
      queryParameters = queryParameters.set('since', since);
    }
    let headers = this.defaultHeaders;
    // authentication (bearerAuth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function' ?
        this.configuration.accessToken() :
        this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // to determine the Accept header
    let httpHeaderAccepts = [
      'application/json'
    ];
    const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }
    // to determine the Content-Type header
    const consumes = [];
    return this.httpClient.request('get', `${this.basePath}/rules/sync`, {
      params: queryParameters,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress
    });
  }
}
SIFTADMINService.ɵfac = function SIFTADMINService_Factory(t) {
  return new(t || SIFTADMINService)(ɵɵinject(HttpClient), ɵɵinject(BASE_PATH, 8), ɵɵinject(Configuration, 8));
};
SIFTADMINService.ɵprov = ɵɵdefineInjectable({
  token: SIFTADMINService,
  factory: SIFTADMINService.ɵfac
});
/*@__PURE__*/
(function () {
  ɵsetClassMetadata(SIFTADMINService, [{
    type: Injectable
  }], function () {
    return [{
      type: HttpClient
    }, {
      type: undefined,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [BASE_PATH]
      }]
    }, {
      type: Configuration,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();

const APIS = [DefaultService, SIFTADMINService];

var ChangeLog;
(function (ChangeLog) {
  ChangeLog.ChangedEnum = {
    Topics: 'topics',
    AltSpellings: 'altSpellings',
    AltSenses: 'altSenses',
    LeetMappings: 'leetMappings',
    Flags: 'flags',
    Tasks: 'tasks',
    DELETED: 'DELETED'
  };
})(ChangeLog || (ChangeLog = {}));

/**
 * Rules
 * The filter works as a series of rules so that each word can be mapped to a rule.  So \"Happy\" can become \"happy\" and \"b4d\" and become \"bad\".    With this API you can manage your rules.
 *
 * OpenAPI spec version: 2.0.3
 * Contact: support@twohat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
const Flag = {
  ENABLED: 'ENABLED',
  DELETED: 'DELETED',
  COMMON: 'COMMON',
  WATCH: 'WATCH',
  SKIP: 'SKIP',
  PHRASERULE: 'PHRASE_RULE',
  USERNAME: 'USERNAME',
  FIRSTNAME: 'FIRST_NAME',
  LASTNAME: 'LAST_NAME',
  CITY: 'CITY',
  STATE: 'STATE',
  COUNTRY: 'COUNTRY',
  EMAILADDRESS: 'EMAIL_ADDRESS',
  DICT: 'DICT',
  OBJ: 'OBJ',
  GENERATED: 'GENERATED',
  MODERATED: 'MODERATED',
  WORD: 'WORD',
  NOUN: 'NOUN',
  VERB: 'VERB',
  PRONOUN: 'PRONOUN',
  ADJECTIVE: 'ADJECTIVE',
  ADVERB: 'ADVERB',
  CONJ: 'CONJ',
  DET: 'DET',
  INTER: 'INTER',
  PROPERNOUN: 'PROPER_NOUN',
  BIGRAM: 'BIGRAM',
  NGRAM: 'NGRAM',
  SIMPLIFIED: 'SIMPLIFIED'
};

class ApiModule {
  constructor(parentModule, http) {
    if (parentModule) {
      throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
    }
    if (!http) {
      throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
        'See also https://github.com/angular/angular/issues/20575');
    }
  }
  static forRoot(configurationFactory) {
    return {
      ngModule: ApiModule,
      providers: [{
        provide: Configuration,
        useFactory: configurationFactory
      }]
    };
  }
}
ApiModule.ɵmod = ɵɵdefineNgModule({
  type: ApiModule
});
ApiModule.ɵinj = ɵɵdefineInjector({
  factory: function ApiModule_Factory(t) {
    return new(t || ApiModule)(ɵɵinject(ApiModule, 12), ɵɵinject(HttpClient, 8));
  },
  providers: [
    DefaultService,
    SIFTADMINService
  ],
  imports: [
    []
  ]
});
/*@__PURE__*/
(function () {
  ɵsetClassMetadata(ApiModule, [{
    type: NgModule,
    args: [{
      imports: [],
      declarations: [],
      exports: [],
      providers: [
        DefaultService,
        SIFTADMINService
      ]
    }]
  }], function () {
    return [{
      type: ApiModule,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: HttpClient,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();

/**
 * Generated bundle index. Do not edit.
 */

export {
  APIS,
  ApiModule,
  BASE_PATH,
  COLLECTION_FORMATS,
  ChangeLog,
  Configuration,
  DefaultService,
  Flag,
  SIFTADMINService
};
//# sourceMappingURL=rules-swagger-client.js.map

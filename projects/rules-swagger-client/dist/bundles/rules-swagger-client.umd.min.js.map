{
  "version": 3,
  "sources": ["../../../../node_modules/tslib/tslib.es6.js", "ng://rules-swagger-client/encoder.ts", "ng://rules-swagger-client/variables.ts", "ng://rules-swagger-client/configuration.ts", "ng://rules-swagger-client/api/default.service.ts", "ng://rules-swagger-client/api/sIFTADMIN.service.ts", "ng://rules-swagger-client/api/api.ts", "ng://rules-swagger-client/model/changeLog.ts", "ng://rules-swagger-client/api.module.ts", "ng://rules-swagger-client/model/flag.ts"],
  "names": ["extendStatics", "d", "b", "Object", "setPrototypeOf", "__proto__", "Array", "p", "hasOwnProperty", "__values", "o", "s", "Symbol", "iterator", "m", "i", "call", "length", "next", "value", "done", "TypeError", "CustomHttpUrlEncodingCodec", "_super", "__", "this", "constructor", "prototype", "create", "__extends", "encodeKey", "k", "replace", "encodeValue", "v", "HttpUrlEncodingCodec", "BASE_PATH", "InjectionToken", "COLLECTION_FORMATS", "csv", "tsv", "ssv", "pipes", "Configuration", "configurationParameters", "apiKeys", "username", "password", "accessToken", "basePath", "withCredentials", "selectHeaderContentType", "contentTypes", "_this", "type", "find", "x", "isJsonMime", "undefined", "selectHeaderAccept", "accepts", "mime", "jsonMime", "RegExp", "test", "toLowerCase", "DefaultService", "httpClient", "configuration", "defaultHeaders", "HttpHeaders", "canConsumeForm", "consumes", "consumes_1", "consumes_1_1", "addComment", "language", "text", "body", "clientId", "observe", "reportProgress", "Error", "queryParameters", "HttpParams", "encoder", "set", "headers", "httpHeaderAcceptSelected", "httpContentTypeSelected", "request", "encodeURIComponent", "String", "params", "deleteAlternateSense", "dependency", "publish", "deleteAlternateSpelling", "deleteComment", "commentId", "deleteFlag", "flag", "deleteLeetMapping", "deleteRule", "deleteTopic", "topicId", "getAutocomplete", "prefix", "clientIds", "languages", "limit", "forEach", "element", "append", "getComment", "getRule", "getRuleHistory", "offset", "refresh", "join", "getRules", "ai", "doneByModeratorId", "endDate", "startDate", "lastChangedStartDate", "lastChangedEndDate", "deleted", "publishedStartDate", "publishedEndDate", "altSense", "altSpelling", "leetMapping", "taskId", "tags", "topics", "unresolvedComments", "listComments", "resolveComment", "testRules", "examplesPerRule", "updateAlternateSense", "updateAlternateSpelling", "updateComment", "updateFlag", "updateLeetMapping", "updateRule", "updateRules", "updateTopic", "core", "ɵɵinject", "http", "HttpClient", "factory", "ɵfac", "SIFTADMINService", "deleteRuleHistory", "syncRules", "since", "APIS", "ChangeLog", "ChangedEnum", "Topics", "AltSpellings", "AltSenses", "LeetMappings", "Flags", "Tasks", "DELETED", "ApiModule", "parentModule", "forRoot", "configurationFactory", "ngModule", "providers", "provide", "useFactory", "imports", "ENABLED", "COMMON", "WATCH", "SKIP", "PHRASERULE", "USERNAME", "FIRSTNAME", "LASTNAME", "CITY", "STATE", "COUNTRY", "EMAILADDRESS", "DICT", "OBJ", "GENERATED", "MODERATED", "WORD", "NOUN", "VERB", "PRONOUN", "ADJECTIVE", "ADVERB", "CONJ", "DET", "INTER", "PROPERNOUN", "BIGRAM", "NGRAM", "SIMPLIFIED"],
  "mappings": "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",
  "sourcesContent": ["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "    import { HttpUrlEncodingCodec } from '@angular/common/http';\n\n/**\n* CustomHttpUrlEncodingCodec\n* Fix plus sign (+) not encoding, so sent as blank space\n* See: https://github.com/angular/angular/issues/11058#issuecomment-247367318\n*/\nexport class CustomHttpUrlEncodingCodec extends HttpUrlEncodingCodec {\n    encodeKey(k: string): string {\n        k = super.encodeKey(k);\n        return k.replace(/\\+/gi, '%2B');\n    }\n    encodeValue(v: string): string {\n        v = super.encodeValue(v);\n        return v.replace(/\\+/gi, '%2B');\n    }\n}\n\n", "import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n", "export interface ConfigurationParameters {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n}\n\nexport class Configuration {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length == 0) {\n            return undefined;\n        }\n\n        let type = contentTypes.find(x => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length == 0) {\n            return undefined;\n        }\n\n        let type = accepts.find(x => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n", "/**\n * Rules\n * The filter works as a series of rules so that each word can be mapped to a rule.  So \\\"Happy\\\" can become \\\"happy\\\" and \\\"b4d\\\" and become \\\"bad\\\".    With this API you can manage your rules. \n *\n * OpenAPI spec version: 2.0.3\n * Contact: support@twohat.com\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n *//* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\n\nimport { Observable }                                        from 'rxjs';\n\nimport { Ai } from '../model/ai';\nimport { Body } from '../model/body';\nimport { ChangeLog } from '../model/changeLog';\nimport { ClientId } from '../model/clientId';\nimport { Comment } from '../model/comment';\nimport { CommentInput } from '../model/commentInput';\nimport { ExampleDiff } from '../model/exampleDiff';\nimport { Flag } from '../model/flag';\nimport { InlineResponse200 } from '../model/inlineResponse200';\nimport { ModeratorId } from '../model/moderatorId';\nimport { Rule } from '../model/rule';\nimport { RuleText } from '../model/ruleText';\nimport { Timestamp } from '../model/timestamp';\nimport { Topics } from '../model/topics';\nimport { UpdateTopic } from '../model/updateTopic';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable()\nexport class DefaultService {\n\n    protected basePath = 'https://virtserver.swaggerhub.com/twohat/rules/2.0.3';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (basePath) {\n            this.basePath = basePath;\n        }\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = basePath || configuration.basePath || this.basePath;\n        }\n    }\n\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    private canConsumeForm(consumes: string[]): boolean {\n        const form = 'multipart/form-data';\n        for (const consume of consumes) {\n            if (form === consume) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Add a comment to this rule\n     * Comments are ways to leave a note to say why a person made the decision they did.  Or it could be a question or answer trying to get help on an item. \n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param text The text of the rule you want to work on\n     * @param body \n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;\n    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;\n    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;\n    public addComment(language: string, text: string, body?: CommentInput, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling addComment.');\n        }\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling addComment.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<Comment>('post',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an alternate sense for a rule\n     * This will delete an alternate sense for rule and log the change\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param dependency This is the related text you want to work on.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public deleteAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteAlternateSense.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteAlternateSense.');\n        }\n\n        if (dependency === null || dependency === undefined) {\n            throw new Error('Required parameter dependency was null or undefined when calling deleteAlternateSense.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_senses/${encodeURIComponent(String(dependency))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an alternate spelling for a rule\n     * This will delete an alternate spelling for rule and log the change\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param dependency This is the related text you want to work on.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public deleteAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteAlternateSpelling.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteAlternateSpelling.');\n        }\n\n        if (dependency === null || dependency === undefined) {\n            throw new Error('Required parameter dependency was null or undefined when calling deleteAlternateSpelling.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_spellings/${encodeURIComponent(String(dependency))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a comment\n     * Remove a comment\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param commentId The unique identifier for the comment\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;\n    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;\n    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;\n    public deleteComment(text: string, language: string, commentId: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteComment.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteComment.');\n        }\n\n        if (commentId === null || commentId === undefined) {\n            throw new Error('Required parameter commentId was null or undefined when calling deleteComment.');\n        }\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<InlineResponse200>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an flag for a rule\n     * This will delete a flag for rule and log the change\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param flag The name of the flag to change\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public deleteFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteFlag.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteFlag.');\n        }\n\n        if (flag === null || flag === undefined) {\n            throw new Error('Required parameter flag was null or undefined when calling deleteFlag.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/flags/${encodeURIComponent(String(flag))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a leet mapping for a rule\n     * This will delete a leet mapping for rule and log the change\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param dependency This is the related text you want to work on.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public deleteLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteLeetMapping.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteLeetMapping.');\n        }\n\n        if (dependency === null || dependency === undefined) {\n            throw new Error('Required parameter dependency was null or undefined when calling deleteLeetMapping.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/leet_mappings/${encodeURIComponent(String(dependency))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a rule\n     * This will delete a rule and log the change\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteRule(text: string, language: string, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteRule.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteRule.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<any>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a topic for a rule\n     * This will delete a topic for rule and log the change\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param topicId The topic is the id for topic.  See documentation on Topic for what the ids are\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public deleteTopic(text: string, language: string, topicId: number, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteTopic.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling deleteTopic.');\n        }\n\n        if (topicId === null || topicId === undefined) {\n            throw new Error('Required parameter topicId was null or undefined when calling deleteTopic.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/topic/${encodeURIComponent(String(topicId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get rules that match this prefix\n     * Used for autocomplete so you can add alternate senses and fill out the rule \n     * @param prefix The term you want to search for\n     * @param clientIds Show results for a several given clients.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param languages Which languages does this apply to\n     * @param limit Limit the number of results\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RuleText>>;\n    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RuleText>>>;\n    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RuleText>>>;\n    public getAutocomplete(prefix: string, clientIds?: Array<ClientId>, languages?: Array<string>, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (prefix === null || prefix === undefined) {\n            throw new Error('Required parameter prefix was null or undefined when calling getAutocomplete.');\n        }\n\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (clientIds) {\n            clientIds.forEach((element) => {\n                queryParameters = queryParameters.append('clientIds', <any>element);\n            })\n        }\n        if (languages) {\n            languages.forEach((element) => {\n                queryParameters = queryParameters.append('languages', <any>element);\n            })\n        }\n        if (limit !== undefined && limit !== null) {\n            queryParameters = queryParameters.set('limit', <any>limit);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Array<RuleText>>('get',`${this.basePath}/rules/autocomplete/${encodeURIComponent(String(prefix))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a comment\n     * Get a comment by Id for this item\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param commentId The unique identifier for the comment\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;\n    public getComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;\n    public getComment(text: string, language: string, commentId: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;\n    public getComment(text: string, language: string, commentId: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling getComment.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling getComment.');\n        }\n\n        if (commentId === null || commentId === undefined) {\n            throw new Error('Required parameter commentId was null or undefined when calling getComment.');\n        }\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Comment>('get',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Lookup a specific rule\n     * This will get the specific rule in JSON format\n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getRule(text: string, language: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public getRule(text: string, language: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public getRule(text: string, language: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public getRule(text: string, language: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling getRule.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling getRule.');\n        }\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('get',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a list of all changes on this rule\n     * This will get the full changelog of all changes made to a rule for all clients and languages you are authorized to view. \n     * @param text The text of the rule you want to work on\n     * @param languages Which languages does this apply to\n     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.\n     * @param limit Limit the number of results\n     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. \n     * @param refresh Should the database be refreshed to make sure all the rows are updated before calling.    Don&#x27;t do this in production as you will get latency spike and it may not even be turned on for production Used primarily for integration tests. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ChangeLog>>;\n    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChangeLog>>>;\n    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChangeLog>>>;\n    public getRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, limit?: number, offset?: number, refresh?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling getRuleHistory.');\n        }\n\n\n\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (languages) {\n            languages.forEach((element) => {\n                queryParameters = queryParameters.append('languages', <any>element);\n            })\n        }\n        if (clientIds) {\n            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));\n        }\n        if (limit !== undefined && limit !== null) {\n            queryParameters = queryParameters.set('limit', <any>limit);\n        }\n        if (offset !== undefined && offset !== null) {\n            queryParameters = queryParameters.set('offset', <any>offset);\n        }\n        if (refresh !== undefined && refresh !== null) {\n            queryParameters = queryParameters.set('refresh', <any>refresh);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Array<ChangeLog>>('get',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/changelog`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Search for rules\n     * Will get all the rules you have created in the system. For Enterprise Plus clients with a specific confidentiality agreement you may also have the option to review the Sift rules as well. \n     * @param ai Show items the AI predicts as useful because moderators in the past have taken an action on this items.  Passing an array of objects as params can be tricky at first so here is an example &amp;ai[0][minPrediction]&#x3D;0.50&amp;ai[0][modelName]&#x3D;topic_vulgar&amp;ai[0][maxPrediction]&#x3D;0.95&amp;ai[1][minPrediction]&#x3D;0.10&amp;ai[1][modelName]&#x3D;topic_fraud&amp;ai[1][maxPrediction]&#x3D;0.80  In urlencoded form that would be &amp;ai%5B0%5D%5BminPrediction%5D&#x3D;0.50&amp;ai%5B0%5D%5BmodelName%5D&#x3D;topic_vulgar&amp;ai%5B0%5D%5BmaxPrediction%5D&#x3D;0.95&amp;ai%5B1%5D%5BminPrediction%5D&#x3D;0.10&amp;ai%5B1%5D%5BmodelName%5D&#x3D;topic_fraud&amp;ai%5B1%5D%5BmaxPrediction%5D&#x3D;0.80 \n     * @param doneByModeratorId Only show work done by this moderatorId\n     * @param clientIds Show results for a several given clients.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)\n     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)\n     * @param lastChangedStartDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)\n     * @param lastChangedEndDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)\n     * @param deleted Show deleted items\n     * @param publishedStartDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)\n     * @param publishedEndDate Show results where there was a change between given date in unixtimestamp (milliseconds since Epoch)\n     * @param languages Which languages does this apply to\n     * @param limit Limit the number of results\n     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. \n     * @param altSense Has this word as an alternate sense\n     * @param altSpelling Has this word as an alternate spelling\n     * @param leetMapping Has this word as a leet mapping\n     * @param taskId Is associated with a taskId for doing work\n     * @param tags Only find items matching a certain tag\n     * @param text Text search.  This uses fuzzy matching.\n     * @param topics Only show items for these topics (topicId) between risk level minRisk and maxRisk\n     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Rule>>;\n    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Rule>>>;\n    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Rule>>>;\n    public getRules(ai?: Array<Ai>, doneByModeratorId?: ModeratorId, clientIds?: Array<ClientId>, endDate?: number, startDate?: number, lastChangedStartDate?: Timestamp, lastChangedEndDate?: Timestamp, deleted?: boolean, publishedStartDate?: Timestamp, publishedEndDate?: Timestamp, languages?: Array<string>, limit?: number, offset?: number, altSense?: string, altSpelling?: string, leetMapping?: string, taskId?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (ai) {\n            ai.forEach((element) => {\n                queryParameters = queryParameters.append('ai', <any>element);\n            })\n        }\n        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {\n            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);\n        }\n        if (clientIds) {\n            clientIds.forEach((element) => {\n                queryParameters = queryParameters.append('clientIds', <any>element);\n            })\n        }\n        if (endDate !== undefined && endDate !== null) {\n            queryParameters = queryParameters.set('endDate', <any>endDate);\n        }\n        if (startDate !== undefined && startDate !== null) {\n            queryParameters = queryParameters.set('startDate', <any>startDate);\n        }\n        if (lastChangedStartDate !== undefined && lastChangedStartDate !== null) {\n            queryParameters = queryParameters.set('lastChangedStartDate', <any>lastChangedStartDate);\n        }\n        if (lastChangedEndDate !== undefined && lastChangedEndDate !== null) {\n            queryParameters = queryParameters.set('lastChangedEndDate', <any>lastChangedEndDate);\n        }\n        if (deleted !== undefined && deleted !== null) {\n            queryParameters = queryParameters.set('deleted', <any>deleted);\n        }\n        if (publishedStartDate !== undefined && publishedStartDate !== null) {\n            queryParameters = queryParameters.set('publishedStartDate', <any>publishedStartDate);\n        }\n        if (publishedEndDate !== undefined && publishedEndDate !== null) {\n            queryParameters = queryParameters.set('publishedEndDate', <any>publishedEndDate);\n        }\n        if (languages) {\n            languages.forEach((element) => {\n                queryParameters = queryParameters.append('languages', <any>element);\n            })\n        }\n        if (limit !== undefined && limit !== null) {\n            queryParameters = queryParameters.set('limit', <any>limit);\n        }\n        if (offset !== undefined && offset !== null) {\n            queryParameters = queryParameters.set('offset', <any>offset);\n        }\n        if (altSense !== undefined && altSense !== null) {\n            queryParameters = queryParameters.set('altSense', <any>altSense);\n        }\n        if (altSpelling !== undefined && altSpelling !== null) {\n            queryParameters = queryParameters.set('altSpelling', <any>altSpelling);\n        }\n        if (leetMapping !== undefined && leetMapping !== null) {\n            queryParameters = queryParameters.set('leetMapping', <any>leetMapping);\n        }\n        if (taskId !== undefined && taskId !== null) {\n            queryParameters = queryParameters.set('taskId', <any>taskId);\n        }\n        if (tags) {\n            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));\n        }\n        if (text !== undefined && text !== null) {\n            queryParameters = queryParameters.set('text', <any>text);\n        }\n        if (topics) {\n            topics.forEach((element) => {\n                queryParameters = queryParameters.append('topics', <any>element);\n            })\n        }\n        if (unresolvedComments !== undefined && unresolvedComments !== null) {\n            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Array<Rule>>('get',`${this.basePath}/rules`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List comments on this content item\n     * \n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listComments(text: string, language: string, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Comment>>;\n    public listComments(text: string, language: string, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Comment>>>;\n    public listComments(text: string, language: string, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Comment>>>;\n    public listComments(text: string, language: string, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling listComments.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling listComments.');\n        }\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Array<Comment>>('get',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Mark a comment as resolved (or reopen)\n     * Comments can be marked as needing to be answered. \n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param text The text of the rule you want to work on\n     * @param commentId The unique identifier for the comment\n     * @param body \n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;\n    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;\n    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;\n    public resolveComment(language: string, text: string, commentId: string, body?: Body, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling resolveComment.');\n        }\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling resolveComment.');\n        }\n\n        if (commentId === null || commentId === undefined) {\n            throw new Error('Required parameter commentId was null or undefined when calling resolveComment.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<Comment>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}/resolved`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Test the impact if you where to upload a rule\n     * This will add the rules temporarily in a sandbox environment look for examples of text that might be impacted and send it to the classifier. If the rules contains {{smart_rules}} then it will find all the words in those smart_rules and pull examples with them It will compare the old answer and the new answer and output a list of phrases that are different.  The clientIds param lets you choose which clients to get examples from.  \n     * @param body \n     * @param examplesPerRule how many examples should we get per rule or smart_rule part\n     * @param clientIds Show results for a several given clients.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe?: 'body', reportProgress?: boolean): Observable<Array<ExampleDiff>>;\n    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ExampleDiff>>>;\n    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ExampleDiff>>>;\n    public testRules(body?: Array<Rule>, examplesPerRule?: number, clientIds?: Array<ClientId>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (examplesPerRule !== undefined && examplesPerRule !== null) {\n            queryParameters = queryParameters.set('examplesPerRule', <any>examplesPerRule);\n        }\n        if (clientIds) {\n            clientIds.forEach((element) => {\n                queryParameters = queryParameters.append('clientIds', <any>element);\n            })\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<Array<ExampleDiff>>('put',`${this.basePath}/rules/test`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the current alternate sense (or add if does not exist) with this value.\n     * This will update an alternate spelling for a rule and log the change  Alternate senses will replace this word with another word SOMETIMES.  You can have more than one alt sense and it will choose the best one based on context or the higher risk one if they are tied. Typically alternate senses are tied to smart rules like {{first_name}} \n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param dependency This is the related text you want to work on.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public updateAlternateSense(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateAlternateSense.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateAlternateSense.');\n        }\n\n        if (dependency === null || dependency === undefined) {\n            throw new Error('Required parameter dependency was null or undefined when calling updateAlternateSense.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_senses/${encodeURIComponent(String(dependency))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the current alternate spelling (or add if does not exist) with this value.\n     * This will update an alternate spelling for a rule and log the change  Alternate spellings will replace this word with another word EVERY TIME.  You can have more than one alt spelling and it will choose the best one based on context or the higher risk one if they are tied. \n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param dependency This is the related text you want to work on.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public updateAlternateSpelling(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateAlternateSpelling.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateAlternateSpelling.');\n        }\n\n        if (dependency === null || dependency === undefined) {\n            throw new Error('Required parameter dependency was null or undefined when calling updateAlternateSpelling.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/alt_spellings/${encodeURIComponent(String(dependency))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a comment\n     * Comments are ways to leave a note to say why a person made the decision they did.  Or it could be a question or answer trying to get help on an item. \n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param text The text of the rule you want to work on\n     * @param commentId The unique identifier for the comment\n     * @param body \n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Comment>;\n    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;\n    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;\n    public updateComment(language: string, text: string, commentId: string, body?: Comment, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateComment.');\n        }\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateComment.');\n        }\n\n        if (commentId === null || commentId === undefined) {\n            throw new Error('Required parameter commentId was null or undefined when calling updateComment.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<Comment>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/comments/${encodeURIComponent(String(commentId))}`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the a flag associated (or add if does not exist) with this value.\n     * This will update a flag with this rule  These are a series of special attributes you can add to an item. For instance if you add FIRST_NAME flag it will automatically add an alt_sense of {{first_name}} and add other logic interally to treat it as potential PII \n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param flag The name of the flag to change\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public updateFlag(text: string, language: string, flag: Flag, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateFlag.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateFlag.');\n        }\n\n        if (flag === null || flag === undefined) {\n            throw new Error('Required parameter flag was null or undefined when calling updateFlag.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/flags/${encodeURIComponent(String(flag))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the current leet mapping associated (or add if does not exist) with this value.\n     * This will update a leet mapping with this rule  In many cases letters like ߎ or ⌰ could be used instead of u  You can map those other letters to u and the system will see if it results in a known word when doing so. \n     * @param text The text of the rule you want to work on\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param dependency This is the related text you want to work on.\n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public updateLeetMapping(text: string, language: string, dependency: RuleText, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateLeetMapping.');\n        }\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateLeetMapping.');\n        }\n\n        if (dependency === null || dependency === undefined) {\n            throw new Error('Required parameter dependency was null or undefined when calling updateLeetMapping.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Rule>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/leet_mappings/${encodeURIComponent(String(dependency))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the current rule\n     * This will update the current rule to the following\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param text The text of the rule you want to work on\n     * @param body \n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public updateRule(language: string, text: string, body?: Rule, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateRule.');\n        }\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateRule.');\n        }\n\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<Rule>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Insert/Update rules in the system\n     * This will update a rule and log the change\n     * @param body \n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateRules(body?: Array<Rule>, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;\n    public updateRules(body?: Array<Rule>, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;\n    public updateRules(body?: Array<Rule>, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;\n    public updateRules(body?: Array<Rule>, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<InlineResponse200>('put',`${this.basePath}/rules`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the current topic (or add if does not exist) with this value.\n     * This will update a topic for a rule and log the change\n     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.\n     * @param text The text of the rule you want to work on\n     * @param topicId The topic is the id for topic.  See documentation on Topic for what the ids are\n     * @param body \n     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.\n     * @param publish This will also make the rule live\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Rule>;\n    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rule>>;\n    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rule>>;\n    public updateTopic(language: string, text: string, topicId: number, body?: UpdateTopic, clientId?: number, publish?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling updateTopic.');\n        }\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling updateTopic.');\n        }\n\n        if (topicId === null || topicId === undefined) {\n            throw new Error('Required parameter topicId was null or undefined when calling updateTopic.');\n        }\n\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (language !== undefined && language !== null) {\n            queryParameters = queryParameters.set('language', <any>language);\n        }\n        if (clientId !== undefined && clientId !== null) {\n            queryParameters = queryParameters.set('clientId', <any>clientId);\n        }\n        if (publish !== undefined && publish !== null) {\n            queryParameters = queryParameters.set('publish', <any>publish);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.request<Rule>('put',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/topic/${encodeURIComponent(String(topicId))}`,\n            {\n                body: body,\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n", "/**\n * Rules\n * The filter works as a series of rules so that each word can be mapped to a rule.  So \\\"Happy\\\" can become \\\"happy\\\" and \\\"b4d\\\" and become \\\"bad\\\".    With this API you can manage your rules. \n *\n * OpenAPI spec version: 2.0.3\n * Contact: support@twohat.com\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n *//* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\n\nimport { Observable }                                        from 'rxjs';\n\nimport { ChangeLog } from '../model/changeLog';\nimport { InlineResponse200 } from '../model/inlineResponse200';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable()\nexport class SIFTADMINService {\n\n    protected basePath = 'https://virtserver.swaggerhub.com/twohat/rules/2.0.3';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (basePath) {\n            this.basePath = basePath;\n        }\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = basePath || configuration.basePath || this.basePath;\n        }\n    }\n\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    private canConsumeForm(consumes: string[]): boolean {\n        const form = 'multipart/form-data';\n        for (const consume of consumes) {\n            if (form === consume) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Delete rule history\n     * Will remove all the history items for a rule.  Used for integration tests to reset the state. \n     * @param text The text of the rule you want to work on\n     * @param languages Which languages does this apply to\n     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<Array<ChangeLog>>;\n    public deleteRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChangeLog>>>;\n    public deleteRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChangeLog>>>;\n    public deleteRuleHistory(text: string, languages?: Array<string>, clientIds?: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (text === null || text === undefined) {\n            throw new Error('Required parameter text was null or undefined when calling deleteRuleHistory.');\n        }\n\n\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (languages) {\n            languages.forEach((element) => {\n                queryParameters = queryParameters.append('languages', <any>element);\n            })\n        }\n        if (clientIds) {\n            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<Array<ChangeLog>>('delete',`${this.basePath}/rules/text/${encodeURIComponent(String(text))}/changelog`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Sync the rules from V1 to V2\n     * \n     * @param since Update rules changed since a given date in unixtimestamp (milliseconds since Epoch)  -1 &#x3D; since the last time the command was run    0 &#x3D; reload all rules   \\\\&gt;1 &#x3D; since this timestamp \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public syncRules(since: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;\n    public syncRules(since: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;\n    public syncRules(since: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;\n    public syncRules(since: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (since === null || since === undefined) {\n            throw new Error('Required parameter since was null or undefined when calling syncRules.');\n        }\n\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\n        if (since !== undefined && since !== null) {\n            queryParameters = queryParameters.set('since', <any>since);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (bearerAuth) required\n        if (this.configuration.accessToken) {\n            const accessToken = typeof this.configuration.accessToken === 'function'\n                ? this.configuration.accessToken()\n                : this.configuration.accessToken;\n            headers = headers.set('Authorization', 'Bearer ' + accessToken);\n        }\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n\n        return this.httpClient.request<InlineResponse200>('get',`${this.basePath}/rules/sync`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n", "export * from './default.service';\nimport { DefaultService } from './default.service';\nexport * from './sIFTADMIN.service';\nimport { SIFTADMINService } from './sIFTADMIN.service';\nexport const APIS = [DefaultService, SIFTADMINService];\n", "/**\n * Rules\n * The filter works as a series of rules so that each word can be mapped to a rule.  So \\\"Happy\\\" can become \\\"happy\\\" and \\\"b4d\\\" and become \\\"bad\\\".    With this API you can manage your rules. \n *\n * OpenAPI spec version: 2.0.3\n * Contact: support@twohat.com\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nimport { ClientId } from './clientId';\nimport { LanguageCode } from './languageCode';\nimport { ModeratorId } from './moderatorId';\nimport { Rule } from './rule';\nimport { RuleText } from './ruleText';\nimport { Timestamp } from './timestamp';\n\n/**\n * A record of when a rule was changed \n */\nexport interface ChangeLog { \n    text: RuleText;\n    language: LanguageCode;\n    clientId: ClientId;\n    /**\n     * If a script was used to update this rule give the name of the script here\n     */\n    scriptName?: string;\n    moderatorId?: ModeratorId;\n    changeDate: Timestamp;\n    /**\n     * helpful description of the reason\n     */\n    description?: string;\n    changed?: Array<ChangeLog.ChangedEnum>;\n    oldVersion?: Rule;\n    newVersion: Rule;\n}\nexport namespace ChangeLog {\n    export type ChangedEnum = 'topics' | 'altSpellings' | 'altSenses' | 'leetMappings' | 'flags' | 'tasks' | 'DELETED';\n    export const ChangedEnum = {\n        Topics: 'topics' as ChangedEnum,\n        AltSpellings: 'altSpellings' as ChangedEnum,\n        AltSenses: 'altSenses' as ChangedEnum,\n        LeetMappings: 'leetMappings' as ChangedEnum,\n        Flags: 'flags' as ChangedEnum,\n        Tasks: 'tasks' as ChangedEnum,\n        DELETED: 'DELETED' as ChangedEnum\n    };\n}", "import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\n\nimport { DefaultService } from './api/default.service';\nimport { SIFTADMINService } from './api/sIFTADMIN.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: [\n    DefaultService,\n    SIFTADMINService ]\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n", "/**\n * Rules\n * The filter works as a series of rules so that each word can be mapped to a rule.  So \\\"Happy\\\" can become \\\"happy\\\" and \\\"b4d\\\" and become \\\"bad\\\".    With this API you can manage your rules. \n *\n * OpenAPI spec version: 2.0.3\n * Contact: support@twohat.com\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * What kind of flag is it  You must have ENABLED if you want it to be active, without it it is a disabled rule  Everything from DICT and below is being deprecated \n */\nexport type Flag = 'ENABLED' | 'DELETED' | 'COMMON' | 'WATCH' | 'SKIP' | 'PHRASE_RULE' | 'USERNAME' | 'FIRST_NAME' | 'LAST_NAME' | 'CITY' | 'STATE' | 'COUNTRY' | 'EMAIL_ADDRESS' | 'DICT' | 'OBJ' | 'GENERATED' | 'MODERATED' | 'WORD' | 'NOUN' | 'VERB' | 'PRONOUN' | 'ADJECTIVE' | 'ADVERB' | 'CONJ' | 'DET' | 'INTER' | 'PROPER_NOUN' | 'BIGRAM' | 'NGRAM' | 'SIMPLIFIED';\n\nexport const Flag = {\n    ENABLED: 'ENABLED' as Flag,\n    DELETED: 'DELETED' as Flag,\n    COMMON: 'COMMON' as Flag,\n    WATCH: 'WATCH' as Flag,\n    SKIP: 'SKIP' as Flag,\n    PHRASERULE: 'PHRASE_RULE' as Flag,\n    USERNAME: 'USERNAME' as Flag,\n    FIRSTNAME: 'FIRST_NAME' as Flag,\n    LASTNAME: 'LAST_NAME' as Flag,\n    CITY: 'CITY' as Flag,\n    STATE: 'STATE' as Flag,\n    COUNTRY: 'COUNTRY' as Flag,\n    EMAILADDRESS: 'EMAIL_ADDRESS' as Flag,\n    DICT: 'DICT' as Flag,\n    OBJ: 'OBJ' as Flag,\n    GENERATED: 'GENERATED' as Flag,\n    MODERATED: 'MODERATED' as Flag,\n    WORD: 'WORD' as Flag,\n    NOUN: 'NOUN' as Flag,\n    VERB: 'VERB' as Flag,\n    PRONOUN: 'PRONOUN' as Flag,\n    ADJECTIVE: 'ADJECTIVE' as Flag,\n    ADVERB: 'ADVERB' as Flag,\n    CONJ: 'CONJ' as Flag,\n    DET: 'DET' as Flag,\n    INTER: 'INTER' as Flag,\n    PROPERNOUN: 'PROPER_NOUN' as Flag,\n    BIGRAM: 'BIGRAM' as Flag,\n    NGRAM: 'NGRAM' as Flag,\n    SIMPLIFIED: 'SIMPLIFIED' as Flag\n};"]
}
